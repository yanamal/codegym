---
layout: framed
---

<div style="position:fixed;top:0;left:0;right:0;bottom:0;">

<div id="instructions" class="carousel slide" data-interval="false">
  <div class="carousel-inner">
    <div class="item active">
      <div class="instruction container-margins">
        <h2><%= @document.title %> <small><%= @document.subtitle %></small></h2>
        <p><%- @document.mission %>
      </div>
    </div>
    <% if @document.instructions then for inst in @document.instructions: %>
    <div class="item">
      <div class="instruction container">
        <h2><%= inst.title %> <small><%= inst.subtitle %></small></h1>
        <p><%- inst.mission %>
      </div>
    </div>
    <% end %>
  </div>
  <a class="left carousel-control" href="#instructions" style="display:none" data-slide="prev"><span class="glyphicon glyphicon-chevron-left" style="left:5px"></span></a>
  <a class="right carousel-control" href="#instructions" data-slide="next"><span class="glyphicon glyphicon-chevron-right" style="right:5px;left:inherit"></span></a>

<% if @document.instructions: %>
<div id="more" class="btn btn-default topright">Learn More&nbsp;
<span class="glyphicon glyphicon-circle-arrow-right"></span></div>
<% end %>
</div>

<% if @document.teaser : %>
<xmp id="teaser" class="data"><%- @document.teaser %></xmp>
<% end %>

<xmp id="starter" class="data"><%- @document.code %></xmp>
<xmp id="hint" class="data"><%- @document.hint %></xmp>

<div id="blocks" title="Toggle Code and Blocks" class="btn btn-default pull-left gap-right" style="background-color:#8fbfef;color:white;position:absolute;left:0;height:90px;padding:30px 1px;border-top-left-radius:17px;border-bottom-left-radius:17px;border-top-right-radius:0;border-bottom-right-radius:0;z-index:1;"><span class="glyphicon glyphicon-indent-left"></span></div>
<div id="codeframe" class="container-margins" style="flex-grow:1">
</div>

<center class="container-margins reflinks">
<!-- TODO: figure out what teaser is for for and/or remove; currently broken?-->
<% if @document.teaser : %>
<div id="intro" title="Show hint again" class="btn btn-default pull-left gap-right"><span class="glyphicon glyphicon-repeat"></span></div>
<% end %>
<div id="reset" title="Reset code to original" class="btn btn-default pull-left gap-right">Reset</div>
<% if not @document.refs: %>
<span class="btn">&nbsp;</span>
<% end %>
<% if @document.refs: %>
<span class="btn"><a target="reference" style="color:inherit;text-decoration:inherit" href="/ref/reference.html">Reference:&nbsp;</a></span>
<!-- TODO: add custom "upload" button here -->
<div id="save" title="Save to your own website" class="btn btn-default pull-right gap-right"><span class="pencil-icon"></span></div>
<% for ref in (@document.refs or []): %><a target="reference" class="btn btn-default gap-right" href="/ref/<%= ref.replace(/\s/g, '_') %>.html"><%=ref%></a><% end %>
<% end %>
</center>
</div>

</div> <!-- end flex container -->
<xmp id="setupcode" style="display:none">
# common setup code here.
window.print = ->
  write 'Try using <b>write</b> instead of <b>print</b>.'
# remove default error handling UI.
window.removeEventListener 'error', see
thepopup = null
popup = (t) ->
  if $('#error-advice').length
    thepopup = $('#error-advice')
  if thepopup
    thepopup.html t
    return
  thepopup = write """
    <center>#{t}</center>
  """
  thepopup.css
    background: rgba(240,240,240,0.8)
    fontFamily: 'Arial'
    margin: '5px 15%'
    padding: '8px'
    borderRadius: '8px'
    boxShadow: '0 0 5px dimgray'

hints = null
lasterrorevent = null

$(window).on 'error', (e) ->
  lasterrorevent = e
  if hints then do hints

<%- @content %>
</xmp>

<!-- TODO: import dog lib from a common repo? the tricky thing is that it's basically being used as a string here. -->
<xmp id="doglib" style="display:none">
// ~~~ Fake connections ~~~

post = function(message) {
  debug(message); // TODO: remove
  if(["feed", "vibrate"].includes(message.type)){
    write(message.type+'!');
  }
};

// ~~~ API ~~~

// TODO: just use click for tap in the composer.

tap = function (fn) {
  click(fn);
};

$.fn.tap = function (fn) {
  this.on('touchstart', fn);
};

// set size of a turtle - works with the default turtle and (hopefully) with any jquery object.
setSize = function(newSize) {
  this.animate({turtleScale: newSize});
};

// end round - the implication is that it ended without success/feeding.
// TODO: better name?..
endRound = function() {
  finishRound(false);
};

//  ~~ Communicating with app ~~
feed = function() {
  post({type:'feed'});
  finishRound();
};

vibrate = function() {
  post({type:'vibrate'});
};

// ~~ Logic for setting rounds and difficulty ~~
var justStarted = true;
var round;
var roundData = []; // data from previous rounds: time, completion, etc.
var thisRoundStart;

var roundSetupFunc = function(){}; // naive 'event handler': function for what to do on round setup.

// TODO: also make sure the round set-up logic happens for first/0th round. This currently combines end-round with beginning-round logic.
startNewRound = function() {
  if(justStarted) {
    // just started game
    justStarted = false;

    round = 0;
    roundData = [];
  }
  else {
    round++;
  }

  thisRoundStart = Date.now();
  roundSetupFunc(); // TODO: safety checks that this is actually a function
}

finishRound = function(success=true) {
  var thisRoundEnd = Date.now();
  var thisRoundData = {
    // TODO: round number/id?
    success:success,
    start: thisRoundStart,
    end: thisRoundEnd,
    duration: thisRoundEnd - thisRoundStart // TODO: account for pausing-type behavior
  };

  post({type:'roundData', payload: thisRoundData});
  roundData[round] = thisRoundData;

  startNewRound(); // TODO: options for finishing game after a certain time, rounds, rewards, etc.
};

onRoundStart = function(callback) {
  roundSetupFunc = callback;
};

// ~~~ Difficulty Logic ~~~ (note: rewritten in ES5-style objects)



var baselineEasyTime = 4000; // baseline for what's always considered "easy" - if the dog completes rounds in < 4 sec.

function DifficultyPicker(easiest, hardest) {
    // TODO: also options to specify max/min, in case of non-linear and/or 'to infinity' types.
    this.easiest = easiest;
    this.hardest = hardest;
    this.roundDifficulties = [];
    this.baselineRoundsLeft = 3; // rounds to spend in "spin-up" - establishing baseline params (could optionally pass in to constructor)
    this.baselineRoundsDone = 0;
    this.baselineTime = baselineEasyTime; // default baseline
    this.totalBaseline = 0;
}

// helper function to set difficulty for this round, and communicate it to the parent app.
// TODO: private?
DifficultyPicker.prototype.setDifficulty = function(diff) {
  this.roundDifficulties[round] = diff;
  post({type:'difficulty', payload: diff});
  return diff;
};


// pick a difficulty. This should most commonly be called as part of the set-up for a new round.
// TODO: one 'learning challenge' could be to rename the instance to something really silly.
DifficultyPicker.prototype.pick = function() {
  // if already decided on a difficulty for this round, keep returning the same one.
  if(round in this.roundDifficulties) {
    console.log('picked same difficulty');
    return this.roundDifficulties[round];
  }

  var prevRound = round - 1;

  // if still calculating baseline
  if(this.baselineRoundsLeft >= 0) {

    if(prevRound in roundData) {
      // if there is data from the previous round
      var prevTime = roundData[prevRound].duration;
      this.totalBaseline += prevTime;

      // TODO: maybe don't nest in if above?.. separate if?..
      if(this.baselineRoundsLeft <= 0 && this.baselineRoundsDone > 0) {
        this.baselineTime = this.totalBaseline / this.baselineRoundsDone

        post({type:'baselineTime', payload: this.baselineTime});
        // TODO: move on to actual difficulty calculation here, since we know
      }
    }

    this.baselineRoundsLeft--;
    this.baselineRoundsDone++;

    return this.setDifficulty(this.easiest); // TODO: this happens n+1 times?
  }

  // fallthrough - adjust difficulty by comparing prev. round's timing to baseline 
  // (this is hopefully creating a negative feedback loop s.t. the difficulty is adjusted to keep the timing close to the baseline)
  // TODO: eventually generalize this whole function to use other data than timing (e.g. falses/bad actions, round-failures)
  
  if( (prevRound in roundData) && (prevRound in this.roundDifficulties)) {
    var baselineFraction = this.baselineTime / roundData[prevRound].duration; // > 1 = 'too easy', < 1 = 'too hard'.
    var difficultyFraction; // scope stuff - TODO: something better?
    // TODO: double-check this logic for when easiest < hardest.
    if(baselineFraction <= 1) {
      // too hard
      difficultyFraction = (this.roundDifficulties[prevRound] - this.easiest) * baselineFraction
      return this.setDifficulty(this.easiest + difficultyFraction);
    } else {
      // too easy
      difficultyFraction = (this.roundDifficulties[prevRound] - this.hardest) / baselineFraction;
      return this.setDifficulty(this.hardest + difficultyFraction);
    }
    // TODO: randomness?
    // TODO: less naive calculation: rely less on easiest/hardest, don't assume difficulty is linear between them.
  } 

  return this.setDifficulty(this.easiest);// most fallthrough - not enough data (i.e. no prevround)

};

// ~~~ some set-up ~~~

document.body.style.backgroundColor = "cadetblue";
ht()

</xmp>

</article>
<script src="//pencilcode.net/lib/pencilcodeembed.js"></script>
<script>

function fixbase() {
  if (!window.$) return; // skip if jquery is undefined.
  if ($('base').length == 0) {
    $(document.head).append('<base>');
  }
  $('base').attr('href', "BASEURL");
}
var fixbasescript =
  fixbase.toString().replace('BASEURL', location.href.replace(/^http.?:/, ''))
      + "\nfixbase();";

$('.carousel').carousel();
function updatePagers() {
  var self = $(this);
  self.children('.carousel-control').show();
  if ($('.carousel-inner .item:first').hasClass('active')) {
    self.children('.left.carousel-control').hide();
  }
  if ($('.carousel-inner .item:last').hasClass('active')) {
    self.children('.right.carousel-control').hide();
  }
}
$('#instructions').each(updatePagers).on('slid', '', updatePagers);

function storageName() {
  return 'gym:' + location.pathname;
}

function loadStorage() {
  try {
    return localStorage.getItem(storageName()) || null;
  } catch (e) {
    return null;
  }
}

function saveStorage(c) {
  try {
    if (!c) {
      localStorage.removeItem();
    } else {
      localStorage.setItem(storageName(), c);
    }
  } catch (e) { }
}

var cf = document.getElementById('codeframe'),
    starter = document.getElementById('starter'),
    originalCode = starter.textContent,
    code = loadStorage() || originalCode,
    modified = (code.trim() != originalCode.trim()),
    setup = document.getElementById('setupcode').innerHTML,
    doglib = document.getElementById('doglib').innerHTML,
    pce = new PencilCodeEmbed(cf);

pce.on('update', function(c) {
  $('#reset').toggleClass('btn-highlight', (c.trim() != originalCode.trim()));
  saveStorage(c);
});

var mode = '';
<% if @document.mode: %>
mode = "<%= @document.mode %>";
<% end %>

var blockMode = <%= !!(@document.blocks) %>;

if (navigator.userAgent.indexOf('Trident') != -1) {
  pce.on('load', function() {
    pce.setupScript([
      {code: fixbasescript, type: 'text/javascript'},
      {code: setup, type: 'text/coffeescript'},
      {code: doglib, type: 'text/javascript'}
    ]);
    pce.setCode(code);
  });
  pce.beginLoad({mode:mode, blocks:blockMode});
} else {
  // Using the url for all initialization is less buggy, if supported
  // URLs are long enough.
  pce.beginLoad({code: code, mode: mode, blocks:blockMode, setup: [
    {code: fixbasescript, type: 'text/javascript'},
    {code: setup, type: 'text/coffeescript'},
    {code: doglib, type: 'text/javascript'}
  ]});
}

console.log(defaultPalette.knownFunctions);

pce.on('load', function() {
  pce.setBlockOptions(defaultPalette.blocks, {functions: defaultPalette.knownFunctions});
});

$('#blocks').click(function() {
  blockMode = !blockMode;
  pce.setBlockMode(blockMode);
});

$('#more').click(function() { $('#instructions').carousel('next'); });
$('#reset').click(function() {
  pce.setCode(originalCode);
  // setCode also resets the block options. I think this is a bug.
  pce.setBlockOptions(defaultPalette.blocks, {functions: defaultPalette.knownFunctions});
});

function doresize() {
  $('#codeframe').height(
    $(window).height() -
    $('#instructions').outerHeight() -
    $('.reflinks').outerHeight());
}

var defaultname = window.location.pathname.replace(/^.*\/|\.[^\/\.]*$/g, '') +
  (mode ? "." + mode : "");

$('#save').click(function() {
  $('#tlayer').hide();
  pce.save(defaultname);
});

$('.btn[title]').tooltip();

doresize();
$(window).resize(doresize);

if ($('#teaser').length) {
  $(cf).append('<div id="tlayer"></div>');
  var hint_contents =
    '<!doctype html>\n' +
    '<html><base href="' + location.href + '">\n' +
    '<body><script src="//pencilcode.net/turtlebits.js" ' +
    'crossorigin="anonymous"><\x2fscript><script type="text/coffeescript">' +
    $(teaser).text() + '<\x2fscript></body></html>';
  function runteaser() {
    $('#tlayer').html('<iframe class="teaser" id="tframe"></iframe>' +
      '<div title="close the example" data-placement="left" ' +
        'class="closebox glyphicon glyphicon-remove-circle"></div>');
    $('#tframe')[0].contentWindow.location.href = 'about:blank';
    $('#tframe')[0].contentWindow.document.open();
    $('#tframe')[0].contentWindow.document.write(hint_contents);
    $('#tframe')[0].contentWindow.document.close();
    $('#tlayer .closebox').tooltip().click(function() {
      $('#tlayer').fadeOut();
    });
  }
  if (modified) {
    $('#tlayer').hide();
  } else {
    runteaser();
  }
  $('#intro').click(function() {
    $('#tlayer').show();
    runteaser();
  });
  setTimeout(function() {
    if ($('#tlayer').is(':visible')) {
      $('#tlayer .closebox').tooltip('show');
    }
  }, <%- @document.teasersecs || 20 %> * 1000);
}

</script>
